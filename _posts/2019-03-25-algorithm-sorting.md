---
layout: article
title: 算法 —「排序」十大排序算法汇总
tags: 算法

lang: zh-Hans
key: Algorithm_Sorting
pageview: true
toc: true
show_subscribe: false
---

## 一、选择排序

### 1. 思想

**将最 小/大 的数交换到待排序序列的最前面。**

首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么就和自己交换）。在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

### 2. 图解过程

<div align="center">  <img src="/img/algorithmic_selection_sort.png" width="80%"/> </div><br>

### 3. 核心代码

```java
public static void selectionSort(int[] arr) {
  
    if (arr == null || arr.length < 2) return;
  
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i；//寻找当前循环最小元素的下标
        for (int j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i, minIndex);
    }
}
```

### 4. 算法分析

#### Ⅰ. 时间复杂度

若待排序的元素总数为 N，外层循环 N 次（本文代码简写外层循环 N-1 次，不影响复杂度分析），第一次内循环比较 N-1 次（与除了本身的所有元素进行比较，找出最值），第二次内循环比较 N-2 次，以此类推，最后一次内循环比较 1 次，总共比较 (N-1) + (N-2) + ... + 1 次，等差求和，再乘上外层循环次数，共循环 N(N-1)/2 次，每次进行常数次的比较、赋值操作，时间复杂度为 $O(N^2)$。

#### Ⅱ. 额外空间复杂度

未借助其它辅助空间，$O(1)$。

#### Ⅲ. 稳定性

排序算法的稳定性：假设有两个相同大小的数，排序后能否维持排序前的顺序不变呢？若能维持，则说明是稳定的排序。

假设排序：5，8，5，2，9，第一次选择排序后第一个 5 与 2 交换，变为：2，8，5，5，9，第一个 5 交换到了另一个 5 的后边。

所以，选择排序不是稳定排序。

## 二、冒泡排序

### 1. 思想

**每轮冒泡（循环）把最小/大的数放在最后。**

对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟都会将最小或最大的元素交换的顶端，最终达到完全有序，例如，升序排列，就是最大的元素移动后面的过程。

### 2. 图解过程

<div align="center">  <img src="/img/algorithmic_bubble_sort.png" width="80%"/> </div><br>

冒泡排序升序排列的整个过程如下图，数组共包含 6 个元素，第一轮将 6 个元素中最大的元素「11」交换至数组的最后；第二轮将剩下 5 个元素中的最大元素「8」交换至「11」的前面。依次执行，直到所有的元素比较完成。总的来说，冒泡排序升序排列就是不断将最大的元素移动到后面的过程。

<div align="center">  <img src="/img/algorithmic_bubble_sort_1.gif" width="60%"/> </div><br>

### 3. 核心代码

```java
public static void bubbleSort(int[] arr){
  
    if(arr == null || arr.length < 2) return;
  
    for(int e = arr.length - 1; e > 0; e--){
        for(int i = 0; i < e; i++){
            if(arr[i] > arr[i + 1]){
                swap(arr, i, i + 1);
}}}}
```

从上面的动图可以看出，当将最大的两个元素交换到正确位置时，前面的4个元素已经排序完成，为了减少不必要的比较，可以增加一个标志位，判断排序的结果，只要有一个轮次没有发生交换，表示数组已经排序完成，不再执行下面的轮次。

### 4. 算法分析

#### Ⅰ. 时间复杂度

若数组为倒序，即所有的轮次都必须执行完（最坏情况），比较次数为 `n-1 + n-2 +...+ 1 = n(n-1)/2`，交换次数与比较次数相同，所以时间复杂度为$O(N^2)$。

#### Ⅱ. 额外空间复杂度

未借助其它辅助空间，$O(1)$。

#### Ⅲ、稳定性

冒泡排序每次都比较相邻的元素，只有前者比后者大才交换位置，相同大小的数，原本在前面，不可能「冒」到另一个后面。

所以，冒泡排序是一种稳定的排序方法。


## 三、插入排序

### 1. 思想

**维护一个有序列，不停把新元素插入其中。**

插入排序的工作方式像许多人排序一手扑克牌，开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的的位置，从右到左将它与已在手中的每张牌进行比较，选择正确位置进行插入，这样，当桌子上的牌全部插入到手中，手中的扑克牌则是所有扑克牌的已排序状态。

### 2. 图解过程

<div align="center">  <img src="/img/algorithmic_insertion_sort.png" width="80%"/> </div><br>

### 3. 核心代码

```java
public static void insertionSort(int[] arr){
  
    if(arr == null || arr.length < 2) return;
  
    for(int i = 1; i < arr.length; i++){
        for(int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--){
            swap(arr, j, j + 1);
    }
  }
}
```

### 4. 算法分析

#### Ⅰ. 时间复杂度

最坏的情况是待排序数组完全逆序，也就是每一次插入都要和有序集合中的所有元素进行比较，插入第二个元素时需要与前 1 个元素进行比较，插入第3个元素时，需要与前 2 个元素比较，以此类推，插入前 N 个元素需要与前 N-1 个元素比较。`1 + 2 + 3 + ... + (N-1)`，结果为 (N-1)*N/2，即 $O(N^2)$。

最好的情况是待排序数组已经是有序的了，每插入一个元素只需要和前一个元素进行比较，复杂度为 $O(N)$。

#### Ⅱ. 额外空间复杂度

未借助其它辅助空间，$O(1)$。

#### Ⅲ. 稳定性

插入排序是从前向后依次选择目标向前插入，向前插入时，遇到相同的数，插在相同的数后边。

所以，插入排序是稳定的排序算法。

## 四、希尔排序

### 1. 思想

**通过粗粒度的插入排序改善数列的有序程序，逐步细化，直到间隔为 1。**

希尔排序是对直接插入排序的改进算法，在使用直接排序算法时，如果序列很长，且无序程度较高，向前插入一次可能导致移动的操作很大。如果原序列相对有序（小的数大致在前，大的数大致在后），则能缓解这一问题。希尔排序就是在插入排序的之前进行了粗略的排序，使原序列相对有序。

### 2. 图解过程

<div align="center">  <img src="/img/algorithmic_shell_sort.png" width="80%"/> </div><br>

间隔 D 有很多中选择，此处使用的是希尔增量 D = n/2, n/4 ,..., 1。

### 3. 核心代码

```java
public static void shellSort(int[] arr){
    
    if(arr == null || arr.length < 2) return;

    for(int D = arr.length / 2; D >= 1; D = D / 2){
        for(int i = D; i < arr.length; i++){
            int j = i;
            int temp = number[j];//要插入的值
            int insert_position = j;

            while(j - D >= 0 && temp < arr[j - D]){
                arr[j] = arr[j - D];
                j -= D;
            }
            arr[j] = temp;
        }
    }
}
```

### 4. 复杂度分析

#### Ⅰ. 时间复杂度

希尔排序最坏的时间复杂度依然为 $O(N^2)$，但其能够有效改善直接插入排序序列无序且长度大时的大长度数列移位。希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能，本文使用的是希尔增量，还有 Hibbard 增量，时间复杂度为 $O(N^{1.5})$。

#### Ⅱ. 额外空间复杂度

未借助其它辅助空间，$O(1)$。

#### Ⅲ. 稳定性

与直接插入排序不同，希尔排序中的分组插入可能导致顺序移位。

所以，插入排序是稳定的排序算法。