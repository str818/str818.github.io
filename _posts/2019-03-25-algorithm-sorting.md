---
layout: article
title: 算法 —「排序」十大排序算法汇总
tags: 算法

lang: zh-Hans
key: Algorithm_Sorting
pageview: true
toc: true
show_subscribe: false
---

## 一、选择排序

### 1. 思想

**将最 小/大 的数交换到待排序序列的最前面。**

首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小元素那么就和自己交换）。在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法叫做选择排序，因为它在不断地选择剩余元素之中的最小者。

### 2. 图解过程

<div align="center">  <img src="/img/algorithmic_selection_sort.png" width="80%"/> </div><br>

### 3. 核心代码

```java
public static void selectionSort(int[] arr) {
  
    if (arr == null || arr.length < 2) return;
  
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i；//寻找当前循环最小元素的下标
        for (int j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i, minIndex);
    }
}
```

### 4. 算法分析

#### Ⅰ. 时间复杂度

若待排序的元素总数为 N，外层循环 N 次（本文代码简写外层循环 N-1 次，不影响复杂度分析），第一次内循环比较 N-1 次（与除了本身的所有元素进行比较，找出最值），第二次内循环比较 N-2 次，以此类推，最后一次内循环比较 1 次，总共比较 (N-1) + (N-2) + ... + 1 次，等差求和，再乘上外层循环次数，共循环 N(N-1)/2 次，每次进行常数次的比较、赋值操作，时间复杂度为 $O(N^2)$。

#### Ⅱ. 额外空间复杂度

未借助其它辅助空间，$O(1)$。

#### Ⅲ. 稳定性

排序算法的稳定性：假设有两个相同大小的数，排序后能否维持排序前的顺序不变呢？若能维持，则说明是稳定的排序。

假设排序：5，8，5，2，9，第一次选择排序后第一个 5 与 2 交换，变为：2，8，5，5，9，第一个 5 交换到了另一个 5 的后边。

所以，选择排序不是稳定排序。

## 二、冒泡排序

### 1. 思想

**每轮冒泡（循环）把最小/大的数放在最后。**

对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟都会将最小或最大的元素交换的顶端，最终达到完全有序，例如，升序排列，就是最大的元素移动后面的过程。

### 2. 图解过程

<div align="center">  <img src="/img/algorithmic_bubble_sort.png" width="80%"/> </div><br>

冒泡排序升序排列的整个过程如下图，数组共包含 6 个元素，第一轮将 6 个元素中最大的元素「11」交换至数组的最后；第二轮将剩下 5 个元素中的最大元素「8」交换至「11」的前面。依次执行，直到所有的元素比较完成。总的来说，冒泡排序升序排列就是不断将最大的元素移动到后面的过程。

<div align="center">  <img src="/img/algorithmic_bubble_sort_1.gif" width="60%"/> </div><br>

### 3. 核心代码

```java
public static void bubbleSort(int[] arr){
  
    if(arr == null || arr.length < 2) return;
  
    for(int e = arr.length - 1; e > 0; e--){
        for(int i = 0; i < e; i++){
            if(arr[i] > arr[i + 1]){
                swap(arr, i, i + 1);
}}}}
```

从上面的动图可以看出，当将最大的两个元素交换到正确位置时，前面的4个元素已经排序完成，为了减少不必要的比较，可以增加一个标志位，判断排序的结果，只要有一个轮次没有发生交换，表示数组已经排序完成，不再执行下面的轮次。

### 4. 算法分析

#### Ⅰ. 时间复杂度

若数组为倒序，即所有的轮次都必须执行完（最坏情况），比较次数为 `n-1 + n-2 +...+ 1 = n(n-1)/2`，交换次数与比较次数相同，所以时间复杂度为$O(N^2)$。

#### Ⅱ. 额外空间复杂度

未借助其它辅助空间，$O(1)$。

#### Ⅲ、稳定性

冒泡排序每次都比较相邻的元素，只有前者比后者大才交换位置，相同大小的数，原本在前面，不可能「冒」到另一个后面。

所以，冒泡排序是一种稳定的排序方法。