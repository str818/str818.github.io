---
layout: article
title: Redis - 底层数据结构
tags: Redis
 
lang: zh-Hans
key: Redis_Deep_Data_Struct
pageview: true
toc: true
show_subscribe: false
---

## 一、简单动态字符串（SDS）

Redis 没有直接使用 C 语言传统的字符串表示，而是自己构建了一种明为简单动态字符串（Simple Dynamic String，SDS）的抽象类型，并将 SDS 用作 Redis 的默认字符串表示。

### 1. 数据结构

SDS 字符串可以看做是对 C 字符串的进一步封装，但是内部实现十分巧妙，有效避免了内存溢出、申请销毁开销过大等问题。

```c
struct __attribute__ ((__packed__)) sdshdrX { // X 代表 bit 长度
    uintX_t len; 					// 字符串的实际长度
    uintX_t alloc;				// buf[] 分配的内存空间大小
    unsigned char flags;	// 用于标记 sdshdr 的结构体类型
    char buf[];						// 字符串的实际存储区域
};

//  Redis 为节约内存占用，分别定义了不同长度 buf 下的数据结构：
struct __attribute__ ((__packed__)) sdshdr5 {...}
struct __attribute__ ((__packed__)) sdshdr8 {...}
struct __attribute__ ((__packed__)) sdshdr16 {...}
struct __attribute__ ((__packed__)) sdshdr32 {...}
struct __attribute__ ((__packed__)) sdshdr64 {...}
```

### 2. 获取长度 O(1)

C 字符串并不记录自身的长度信息，所以为了获取一个 C 字符串的长度需要遍历整个字符串，这个操作的复杂度为 O(N)。而 SDS 在 len 属性中存储了 SDS 本身的长度，所以获取一个 SDS 长度的复杂度仅为 O(1)。

### 3. 杜绝缓冲区溢出

C 字符串不记录自身的长度，所以在进行字符串更新操作时，假设已经分配了足够多的内存，如果假设不成立就会产生缓冲区溢出。而 SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性，当对 SDS 进行修改时，会先检查 SDS 的空间是否满足修改的需求，如果不满足的话，会自动将 SDS 的空间扩展至执行修改所需的大小。

### 4. 内存分配策略

Redis 作为数据库，经常被用于速度要求严苛、数据被品牌修改的场合，如果每次修改字符串的长度都需要执行一次内存重分配的话，那么光是执行内存重分配的时间就会占去修改字符所用时间的一大部分，如果这种修改频繁发生，可能还会对性能造成影响。

通过未使用空间，SDS 实现了「空间预分配」和「惰性空间释放」两种优化策略。

#### I. 空间预分配

空间预分配用于**优化 SDS 字符串增长**操作：当对 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须的空间，还会分配额外的未使用空间。分配策略如下：

- 如果原字符串中的空余空间足够使用（alloc - len >= addlen），那么它并不会进行内存分配

- 如果需要分配空间，且追加后字符串总长度小于定义的`SDS_MAX_PREALLOC(1MB)`，其分配的实际内存大小为所需的两倍，以防备继续追加
- 如果追加后字符串总长度大于 1MB，那么分配的空余内存大小为 1MB

通过这种预分配策略，SDS 将连续增长 N 次字符串所需的内存分配次数从必定 N 次降低为最多 N 次。

#### II. 惰性空间释放

惰性空间释放用于优化 SDS 字符串缩短操作：当缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用 free 属性将这些字节的数量记录起来，并等待将来使用。

通过惰性空间释放策略，SDS 避免了缩短字符串时所需的内存重分配操作，并为将来可能有的增长操作提供了优化。

### 5. 二进制安全

C 字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，这些限制使得 C 字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据。而 SDS 会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据，程序不会对其中的数据做任何限制或过滤。