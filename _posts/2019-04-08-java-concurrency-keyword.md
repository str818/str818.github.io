---
layout: article
title: Java 并发关键字
tags: Java

lang: zh-Hans
key: Java_Concurrency_Keyword
pageview: true
toc: true
show_subscribe: false
---

## 一、Synchronized

### 1. 使用方法

synchronized 块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。线程的执行代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。

具体表现为以下 3 种形式：

- 普通同步方法，锁是当前实例对象。
- 静态同步方法，锁是当前类的 Class 对象。
- 同步方法块，锁是 synchronized 括号里配置的对象。

### 2. 实现原理

#### Ⅰ. 对象锁(Monitor)机制

synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指向同步代码块的结束为止与异常位置。任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来判断一个方法是否声明为同步方法，从而执行相应的同步调用。

synchronized 先天具有重入性，每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。

#### Ⅱ. 获取与释放锁的内存语义

当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。

- 线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了(线程 A 对共享变量所做修改的)消息。
- 线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的(在释放这个锁之前对共享变量所做的修改的)消息。
- 线程 A 释放锁，随后线程 B 获取这个锁，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。

### 3. CAS 操作

CAS 即 Compare ans Swap，是 JDK 提供的非阻塞原子性操作，它通过硬件保证了「比较—更新」操作的原子性。CAS 操作是一种乐观锁策略，它假设没有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然就不会阻塞其它线程的操作。

#### Ⅰ. 操作过程

CAS 操作的过程可以通俗的理解为 CAS(V,O,N)，包含三个值分别为：V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值。当 V 和 O 相同时，也就是说旧值和内存中实际的值相同表明该值没有被其它线程更改过，即该旧值 O 就是目前来说最新的值了，自然而然可以将新值N赋值给 V。反之，V 和 O 不相同，表明该值已经被其它线程改过了则该旧值 O 不是最新版本的值了，所以不能将新值 N 赋给 V，返回 V 即可。当多个线程使用 CAS 操作一个变量时，只有一个线程会成功，并成功更新，其余都会失败。失败的线程会重新尝试，当然也可以选择挂起线程。

CAS 的实现需要硬件指令集的支撑，在 JDK1.5 后虚拟机才可以使用处理器提供的 **CMPXCHG** 指令实现。

#### Ⅱ. 存在问题

（1）ABA 问题

CAS 会在操作值的时候检查值有没有变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。这一问题可以通过添加版本号的方式解决，JDK 1.5 后 Atomic 包中提供了 AtomicStampedReference 来解决 ABA 问题。

（2）循环时间长开销大

自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令，效率会有一定的提升。

（3）只能保证一个共享变量的原子操作

当对一个共享变量执行操作时，可以使用循环 CAS 的方式保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。

### 4. Java 对象头

synchronized 用的锁存在 Java 对象头里，Java 对象头里的 Mark Word 里默认存储对象的 HashCode、分代年龄和锁标记位。

<div align="center">  <img src="/img/java_concurrency_mark_word.png" width="100%"/> </div><br>

### 5. 锁优化







