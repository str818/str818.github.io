---
title: 数据结构相关
permalink: /notes/algorithm/code-data-structure
key: algorithm-code-data-structure
---

## 数组

#### 旋转矩阵

[Leetcode - 48 Rotate Image (Medium)](https://leetcode.com/problems/rotate-image/)

题目描述：将一个 n × n 的矩阵旋转 90°，不能使用额外的辅助空间。

```
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

解题思路：原地旋转，这个时候就需要找规律了，规律：先左右交换，在以对称轴(斜上)交换。

```java
public void rotate(int[][] matrix) {
    for(int i = 0; i<matrix.length; i++){
        for(int j = i; j<matrix[0].length; j++){
            int temp = 0;
            temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    for(int i =0 ; i<matrix.length; i++){
        for(int j = 0; j<matrix.length/2; j++){
            int temp = 0;
            temp = matrix[i][j];
            matrix[i][j] = matrix[i][matrix.length-1-j];
            matrix[i][matrix.length-1-j] = temp;
        }
    }
}
```

#### 最佳买卖时间

[Leetcode - 121 Best Time to Buy and Sell Stock (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

题目描述：给定数组，第 i 个元素的值表示第 i 天时股票的售价，算出最优的利润。

```
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
```

```java
public int maxProfit(int[] prices) {
    int minPrice = Integer.MAX_VALUE;
    int maxProfit = 0;
    for(int i = 0; i < prices.length; i++){
        if(prices[i] < minPrice){
            minPrice = prices[i];
        }
        if(prices[i] - minPrice > maxProfit){
            maxProfit = prices[i] - minPrice;
        }
    }
    return maxProfit;
}
```

## 链表

#### 两数相加

[Leetcode - 2 Add Two Numbers (Medium)](https://leetcode.com/problems/add-two-numbers/)

题目描述：给定两个链表，每个链表表示一个整数，链表的每个结点表示一位数，将两个链表表示的整数相加得到新的链表。

```
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
解题思路：同时遍历两个链表，将相同位置的结点相加，注意加法的进位。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode cur = dummyHead;
    int carry = 0;
    while(l1 != null || l2 != null){
        int x = (l1 != null) ? l1.val : 0;
        int y = (l2 != null) ? l2.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        if(l1 != null) l1 = l1.next;
        if(l2 != null) l2 = l2.next;
    }
    if(carry > 0){
        cur.next = new ListNode(carry);
    }
    return dummyHead.next;
}
```

#### 合并两个有序链表

[Leetcode - 21 Merge Two Sorted Lists (Easy)](https://leetcode.com/problems/merge-two-sorted-lists/)

```
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```

解法一：循环

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode cur = dummyHead;
    while(l1 != null && l2 != null){
        if(l1.val > l2.val){
            cur.next = l2;
            l2 = l2.next;
        }else{
            cur.next = l1;
            l1 = l1.next;
        }
        cur = cur.next;
    }
    if(l1 != null){
        cur.next = l1;
    }
    if(l2 != null){
        cur.next = l2;
    }
    return dummyHead.next;
}
```

解法二：递归

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2){
    if(l1 == null) return l2;
    if(l2 == null) return l1;
    if(l1.val < l2.val){
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else{
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

#### 链表排序

[Leetcode - 148 Sort List (Medium)](https://leetcode.com/problems/sort-list/)

题目描述：对给定的链表进行排序，时间复杂度 O(longn)，并且空间复杂度为常数。

```
Input: 4->2->1->3
Output: 1->2->3->4
```

解题思路：归并排序。

```java
public ListNode sortList(ListNode head) {
    if(head == null || head.next == null) return head;
    ListNode pre = head, slow = head, fast = head;
    while(fast != null && fast.next != null){
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    pre.next = null;
    ListNode l1 = sortList(head);
    ListNode l2 = sortList(slow);
    return merge(l1, l2);
}

public ListNode merge(ListNode l1, ListNode l2){
    ListNode head = new ListNode(0), cur = head;
    while(l1 != null && l2 != null){
        if(l1.val < l2.val){
            cur.next = l1;
            l1 = l1.next;
        }else{
            cur.next = l2;
            l2 = l2.next;
        }
        cur = cur.next;
    }
    if(l1 != null){
        cur.next = l1;
    }
    if(l2 != null){
        cur.next = l2;
    }
    return head.next;
}
```

## 哈希表

#### 两数之和

[Leetcode - 1 Two Sum (Easy)](https://leetcode.com/problems/two-sum/)

题目描述：输出数组中相加结果为 target 的两个元素的索引。

```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

解题思路：可以二层循环遍历所有的结果，但时间复杂度为 $O(n^2)$，可以使用哈希的思想，一次循环，判断当前的元素是否与哈希表中的元素相加等于 target。

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for(int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if(map.containsKey(complement)){
            return new int[]{map.get(complement),i};
        }
        map.put(nums[i],i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

#### 分组字谜

[Leetcode - 49 Group Anagrams (Medium)](https://leetcode.com/problems/group-anagrams/)

题目描述：给定一个字符串数组，将数组中组成字母相同的字符串划分到一起。

```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```
解题思路：很明显需要使用哈希表，但关键的问题是使用什么作为 Key 值，有两种选择，一种是将排序后的字符串作为 Key 值，另一种是使用计数排序，统计字符串中每个字母出现的次数，之后将 26 个数值用特殊符号连接成字符串作为 Key 值。
第一种方便一点，第二种由于使用的是计数排序，时间复杂度更低。

```java
public List<List<String>> groupAnagrams(String[] strs) {
    if (strs.length == 0) return new ArrayList();
    Map<String, List> ans = new HashMap<String, List>();
    for (String s : strs) {
        char[] ca = s.toCharArray();
        Arrays.sort(ca);
        String key = String.valueOf(ca);
        if (!ans.containsKey(key)) ans.put(key, new ArrayList());
        ans.get(key).add(s);
    }
    return new ArrayList(ans.values());
}
```

## 栈和队列

#### 有效的括号

[Leetcode - 20 Valid Parenthese (Easy)](https://leetcode.com/problems/valid-parentheses/)

题目描述：给定字符串，判断括号是否有效。

```
Input: "()[]{}"
Output: true
```

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for (Character c : s.toCharArray()){
        if(c == '('){
            stack.push(')');
        }else if(c == '['){
            stack.push(']');
        }else if(c == '{'){
            stack.push('}');
        }else if(stack.isEmpty() || stack.pop() != c){
            return false;
        }
    }
    return stack.isEmpty();
}
```

#### 最小栈

[Leetcode - 155 Min Stack (Easy)](https://leetcode.com/problems/min-stack/)

题目描述：实现栈的功能，除此之外还要能够返回栈中的最小值。

解题思路：返回最小值时可以遍历栈，但显然时间复杂度太高，可以将每一次的最小值一同压栈，出栈时一同弹出。

```java
class MinStack {
    int min = Integer.MAX_VALUE;
    Stack<Integer> stack = new Stack<Integer>();
    public void push(int x) {
        if(x <= min){          
            stack.push(min);
            min=x;
        }
        stack.push(x);
    }
    public void pop() {
        if(stack.pop() == min) min=stack.pop();
    }
    public int top() {
        return stack.peek();
    }
    public int getMin() {
        return min;
    }
}
```

## 树





#### 将二叉树展开成链表

[Leetcode - 114 Flatten Binary Tree to Linked List (Medium)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)


```
Input:
    1
   / \
  2   5
 / \   \
3   4   6
Output:
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

解题思路：注意是按照先序遍历的顺序展开的。

```java
public void flatten(TreeNode root) {
    if(root == null) return;
    flatten(root.left);
    flatten(root.right);
    TreeNode temp = root.right;
    root.right = root.left;
    root.left = null;
    while(root.right != null) root = root.right;
    root.right = temp;
}
```