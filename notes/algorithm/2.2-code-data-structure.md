---
title: 数据结构相关
permalink: /notes/algorithm/code-data-structure
key: algorithm-code-data-structure
---

## 数组

#### 旋转矩阵

[Leetcode - 48 Rotate Image (Medium)](https://leetcode.com/problems/rotate-image/)

题目描述：将一个 n × n 的矩阵旋转 90°，不能使用额外的辅助空间。

```
Given input matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

解题思路：原地旋转，这个时候就需要找规律了，规律：先左右交换，在以对称轴(斜上)交换。

```java
public void rotate(int[][] matrix) {
    for(int i = 0; i<matrix.length; i++){
        for(int j = i; j<matrix[0].length; j++){
            int temp = 0;
            temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }
    for(int i =0 ; i<matrix.length; i++){
        for(int j = 0; j<matrix.length/2; j++){
            int temp = 0;
            temp = matrix[i][j];
            matrix[i][j] = matrix[i][matrix.length-1-j];
            matrix[i][matrix.length-1-j] = temp;
        }
    }
}
```

## 链表

#### 两数相加

[Leetcode - 2 Add Two Numbers (Medium)](https://leetcode.com/problems/add-two-numbers/)

题目描述：给定两个链表，每个链表表示一个整数，链表的每个结点表示一位数，将两个链表表示的整数相加得到新的链表。

```
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
解题思路：同时遍历两个链表，将相同位置的结点相加，注意加法的进位。

```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode cur = dummyHead;
    int carry = 0;
    while(l1 != null || l2 != null){
        int x = (l1 != null) ? l1.val : 0;
        int y = (l2 != null) ? l2.val : 0;
        int sum = carry + x + y;
        carry = sum / 10;
        cur.next = new ListNode(sum % 10);
        cur = cur.next;
        if(l1 != null) l1 = l1.next;
        if(l2 != null) l2 = l2.next;
    }
    if(carry > 0){
        cur.next = new ListNode(carry);
    }
    return dummyHead.next;
}
```

#### 合并两个有序链表

[Leetcode - 21 Merge Two Sorted Lists (Easy)](https://leetcode.com/problems/merge-two-sorted-lists/)

```
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```

解法一：循环

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    ListNode dummyHead = new ListNode(0);
    ListNode cur = dummyHead;
    while(l1 != null && l2 != null){
        if(l1.val > l2.val){
            cur.next = l2;
            l2 = l2.next;
        }else{
            cur.next = l1;
            l1 = l1.next;
        }
        cur = cur.next;
    }
    if(l1 != null){
        cur.next = l1;
    }
    if(l2 != null){
        cur.next = l2;
    }
    return dummyHead.next;
}
```

解法二：递归

```java
public ListNode mergeTwoLists(ListNode l1, ListNode l2){
    if(l1 == null) return l2;
    if(l2 == null) return l1;
    if(l1.val < l2.val){
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else{
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
}
```

## 哈希表

#### 两数之和

[Leetcode - 1 Two Sum (Easy)](https://leetcode.com/problems/two-sum/)

题目描述：输出数组中相加结果为 target 的两个元素的索引。

```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```

解题思路：可以二层循环遍历所有的结果，但时间复杂度为 $O(n^2)$，可以使用哈希的思想，一次循环，判断当前的元素是否与哈希表中的元素相加等于 target。

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for(int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if(map.containsKey(complement)){
            return new int[]{map.get(complement),i};
        }
        map.put(nums[i],i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

#### 分组字谜

[Leetcode - 49 Group Anagrams (Medium)](https://leetcode.com/problems/group-anagrams/)

题目描述：给定一个字符串数组，将数组中组成字母相同的字符串划分到一起。

```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```
解题思路：很明显需要使用哈希表，但关键的问题是使用什么作为 Key 值，有两种选择，一种是将排序后的字符串作为 Key 值，另一种是使用计数排序，统计字符串中每个字母出现的次数，之后将 26 个数值用特殊符号连接成字符串作为 Key 值。
第一种方便一点，第二种由于使用的是计数排序，时间复杂度更低。

```java
public List<List<String>> groupAnagrams(String[] strs) {
    if (strs.length == 0) return new ArrayList();
    Map<String, List> ans = new HashMap<String, List>();
    for (String s : strs) {
        char[] ca = s.toCharArray();
        Arrays.sort(ca);
        String key = String.valueOf(ca);
        if (!ans.containsKey(key)) ans.put(key, new ArrayList());
        ans.get(key).add(s);
    }
    return new ArrayList(ans.values());
}
```

## 栈和队列

#### 有效的括号

[Leetcode - 20 Valid Parenthese (Easy)](https://leetcode.com/problems/valid-parentheses/)

题目描述：给定字符串，判断括号是否有效。

```
Input: "()[]{}"
Output: true
```

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    for (Character c : s.toCharArray()){
        if(c == '('){
            stack.push(')');
        }else if(c == '['){
            stack.push(']');
        }else if(c == '{'){
            stack.push('}');
        }else if(stack.isEmpty() || stack.pop() != c){
            return false;
        }
    }
    return stack.isEmpty();
}
```

## 树

#### 二叉树的中序遍历

[Leetcode - 94 Binary Tree Inorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-inorder-traversal/)

```
Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
```

解题思路：递归。非递归可以使用栈辅助。

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ansList = new ArrayList<Integer>();
    backtrack(ansList, root);
    return ansList;
}

public void backtrack(List<Integer> ansList, TreeNode root){
    if(root == null) return;
    backtrack(ansList, root.left);
    ansList.add(root.val);
    backtrack(ansList, root.right);
}
```

#### 验证二叉搜索树

[Leetcode - 98 Validate Binary Search Tree (Medium)](https://leetcode.com/problems/validate-binary-search-tree/)

题目描述：给出一个二叉树，判断是否是二叉搜索树。

```
Input:
    2
   / \
  1   3
Output: true
```

解题思路：二叉搜索树需要左子树比根节点小，右子树比根节点大，注意是子树，而不是结点，所以需要子树中的每一个结点都比根节点小/大。

```java
public boolean isValidBST(TreeNode root) {
    return backtrack(root, Long.MAX_VALUE, Long.MIN_VALUE);
}
public boolean backtrack(TreeNode root, long maxValue, long minValue){
    if(root == null) return true;
    if(root.val >= maxValue || root.val <= minValue) return false;
    return backtrack(root.left, root.val, minValue) && backtrack(root.right, maxValue, root.val);
}
```

#### 对称树

[Leetcode - 101 Symmetric Tree (Easy)](https://leetcode.com/problems/symmetric-tree/)

题目描述：判断一个二叉树是不是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

解法一：递归

```java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}

public boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    return (t1.val == t2.val)
        && isMirror(t1.right, t2.left)
        && isMirror(t1.left, t2.right);
}
```

解法二：遍历

```java
public boolean isSymmetric(TreeNode root) {
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    q.add(root);
    while (!q.isEmpty()) {
        TreeNode t1 = q.poll();
        TreeNode t2 = q.poll();
        if (t1 == null && t2 == null) continue;
        if (t1 == null || t2 == null) return false;
        if (t1.val != t2.val) return false;
        q.add(t1.left);
        q.add(t2.right);
        q.add(t1.right);
        q.add(t2.left);
    }
    return true;
}
```