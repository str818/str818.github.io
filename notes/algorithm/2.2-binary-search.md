---
title: 二分查找
permalink: /notes/algorithm/code-binarySearch
key: algorithm-code-binarySearch
---

#### 旋转有序数组的搜索

[Leetcode - 33 Search in Rotated Sorted Array (Medium)](https://leetcode.com/problems/search-in-rotated-sorted-array/)

题目描述：给定一个旋转的有序数组，例如有序数组  [0,1,2,4,5,6,7] 经一次旋转后可得 [4,5,6,7,0,1,2] ，再给定一个 target 值，返回 target 值在数组中的下标，如果不在返回 -1，假设数组中无重复元素，时间复杂度要求为 O(logn)。

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

解题思路：题目要求时间复杂度是 O(logn) ，那就告诉我们要用二分搜索了，但是二分搜索是基于有序序列的，但是给出的数组经过一次旋转之后就不再是有序的了，这时就要添加额外的判断条件。

```java
public int search(int[] A, int target) {
    if(A.length == 0 || A == null) return -1;
    int lo = 0;
    int hi = A.length - 1;
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        if (A[mid] == target) return mid;
        // 一定有一边是有序的
        if (A[lo] <= A[mid]) {
            // 如果不再有序的那一边，就一定在另外一边
            if (target >= A[lo] && target < A[mid]) {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        } else {
            if (target > A[mid] && target <= A[hi]) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
    }
    return A[lo] == target ? lo : -1;
}
```

#### 找到有序序列的指定区间

[Leetcode - 34 Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

题目描述：给定一个有序序列与一个 target 值，求出 target 在有序序列中的区间，时间复杂度要求为 O(logn)，若没有 target 值，则返回 [-1, -1]。

```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```

解题思路：时间复杂度 O(logn)，依旧是二分法，经典的二分法只需找到一个元素，本题需要对二分法进行改进，分两次查找，第一次找到左区间的位置，第二次找到右区间的位置。

```java
public int[] searchRange(int[] nums, int target) {
    if(nums.length == 0) return new int[]{-1, -1};
    int[] ans = new int[]{-1, -1};
    int l = 0, r = nums.length - 1;
    // 左闭区间
    while(l < r){
        int mid = (l + r)/2;
        if(target <= nums[mid]){
            r = mid;
        }else{
            l = mid + 1;
        }
    }

    if(nums[l] != target) return ans;
    ans[0] = l;
	// 右闭区间
    r = nums.length - 1;
    while(l < r){
        int mid = (l + r)/2 + 1;
        if(target >= nums[mid]){
            l = mid;
        }else{
            r = mid - 1;
        }
    }
    ans[1] = r;
    return ans;
}
```

